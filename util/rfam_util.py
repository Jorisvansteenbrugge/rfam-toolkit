#!/usr/bin/python 

'''

@author: ikalvari
'''

import os
import string

#--------CONSTANTS-------- 

#OUTPUT SPECIFIC
FAM_COUNT = 0	# The position of the family count in the data structure

#INPUT SPECIFIC
CM_ACC_HEADER = "ACC      %s\n" #string provided should be the family acc 

#CMSCAN OUTPUT (TBLOUT format)
CMSCAN = 'CC'
FAM_ACC_CC = 1	#The position of family accession no in the data list 
RNA_TYPE_CC = 0 #The position of the family related RNA type


#CMSEARCH OUTPUT (TBLOUT format)
CMSEARCH = 'CS'
FAM_ACC_CS = 3 	#The position of family accession no in the data list 
RNA_TYPE_CS = 2 #The position of the family related RNA type

HL_LENGTH = 18

#RFAM SPECIFIC
FAM_TOTAL = 2450

OUT_EXT = '.out'
DELIMITER = '\t'

#---------------------------------------------FUNCTIONS-----------------------------------------------

def family_extractor(fam_db_dump):

	'''
		This function extracts all family acc from the family.txt table database dump.
		Returns a dictionary with the family accessions as keys and their corresponding
		entry fields as values.
	
		fam_db_dump: The path to the family.txt file under ftp: database_files dir
	'''
	
	ACC_ID = 0

	families = {}

	fp = open(fam_db_dump,'r')

	for line in fp:
		if ('RF' in line):
			line = line.strip().split()
			#organizing data via Accession id, maintaining entry info as values
			families[line[ACC_ID]] = line[1:]

	fp.close()

	return families
	
#----------------------------------------------------------------------------------------------------

def infernal_res_parser(res_file,method=CMSCAN):
	
	'''
		A parser of the tblout output format of Infernal's cmscan and cmsearch tools.
		Returns a dictionary with the number of hits per family as FAM_ACC: list pairs,
		where list is in the form of [hits,RNA_type,description].
		
		res_file: The path to a cmscan/cmsearch output file in tblout format
		method:   CMSCAN/CMSEARCH defines the output format (cmscan by default)
	'''
	import re 
	
	reg_ex = re.compile('[\s#]')
	
	families = {}
	FAM_ACC = None
	RNA_TYPE = None
	
	fp = open(res_file,'r')
	
	#description index 
	DESC_INDEX = HL_LENGTH-1 
	
	if (method == CMSCAN):
		FAM_ACC = FAM_ACC_CC
		RNA_TYPE = RNA_TYPE_CC	
	
	else:	
		FAM_ACC = FAM_ACC_CS
		RNA_TYPE = RNA_TYPE_CS

	#list len for res lines is 21 - no need to drop header lines	
	for line in fp:
		
		if(reg_ex.match(line)!=None):
			continue
		
		line = line.strip().split()

		if (line[0] != '#'): #use this to drop header lines and use last one to get #col
			
			if (line[FAM_ACC] not in families.keys()):
				# 1st element is the count of a specific family in the output file - initialize to 1 hit
				families[line[FAM_ACC]] = [1,line[RNA_TYPE],reduce(lambda x,y: string.join([x,y],'_'),line[DESC_INDEX:])]
					
			#family already in dict
			else:
				count = families[line[FAM_ACC]][FAM_COUNT]
				count = count+1
				families[line[FAM_ACC]][FAM_COUNT] = count
		
	fp.close()
	
	return families

#----------------------------------------------------------------------------------------------------	

def display_infernal_results(families,to_file=True):

	#TO DO: convert this to write output to file (use to_file param) 
	
	'''
		Displays cmscan/cmsearch results as hits/family on screen in a readable form. 
		
		families:  A dictionary generated by infernal_res_parser
	'''
	
	print "\nRfam found %d families" %(len(families)) #number of families found
		
	print "Families with single line hits: %d" %(len(filter(lambda x: families[x][FAM_COUNT]==1,families.keys())))
	print "\nNumber of hits per family:"
	print "--------------------------"

	print "FAM_ACC\tHITs\n"
	
	for fam_acc in sorted(families.keys()):
		print "%s\t%d" %(fam_acc,families[fam_acc][FAM_COUNT])
		
#----------------------------------------------------------------------------------------------------	

def batch_parser(res_dir,method=CMSCAN,to_file=True):
	
	'''
		Parses Infernal's cmscan/cmsearch output files within res_dir and generates
		output files indicating the Family hits per dataset. 
		
		res_dir: This is the directory to the cmscan/cmsearch output files to be parsed
		to_file: When set to True, the function generates an output file  
		method:  Infernal's CMSCAN/CMSEARCH tools 
	'''
	
	inf_out_files = os.listdir(res_dir)
	
	for out_file in inf_out_files:
		
		families = infernal_res_parser(os.path.join(res_dir,out_file),method)

		if (to_file==True):
			new_outfile = out_file.partition('.')[0]+"_res.txt"
			
			fp_out = open(os.path.join(res_dir,new_outfile),'w')
			
			fp_out.write("Rfam found %d families\n" %(len(families))) 					
		
			fp_out.writelines(["Families with single line hits: %d" %(len(filter(lambda x: families[x][FAM_COUNT]==1,families.keys()))), \
			"\n\nNumber of hits per family:", \
			"\n--------------------------", \
			"\n\nFAM_ACC\tHITs\n"])
			
			#write family hits in file
			for key in sorted(families.keys()):
				fp_out.write("%s\t%d\n" %(key,families[key][FAM_COUNT]))
			
		else:
			#display the output on screen
			display_infernal_results(families) 
		
		families = None
		fp_out.close()		
#----------------------------------------------------------------------------------------------------
def cmdispose(cmfile,families):
	
	'''
		This function is the reverse to Infernal's cmfetch removing a list of families 
		from the given Covariance Model (CM) file (Rfam.cm).
		
		cmfile:   The Rfam.cm file containing all Rfam CMs
		families: A list of family accessions to be removed from the cmfile
	'''
	
	fp = open(cmfile,'r')
	contents = fp.readlines()
	fp.close()
	
	for family in families:

		#if the family is not found in the file, jump to next family
		if(contents.count(CM_ACC_HEADER%family)==0):
			continue
		
		#get an index of the family's location within the file
		index = contents.index(CM_ACC_HEADER%family)
		index = index-2	
		line = contents.pop(index)	
		
		#Remove infernal section
		#work all the way removing info up until HMMER3 flag
		while ("HMMER3" not in line):
			line = contents.pop(index)
		#continue removing the HMMER3 section
		while ("//" not in line):
			line = contents.pop(index)
	
	spath = os.path.split(cmfile)
	
	fp = open(os.path.join(spath[0],spath[1].partition('.')[0]+"_new.cm"),'w')
	
	for line in contents:
		fp.write(line)
	
	fp.close()

#----------------------------------------------------------------------------------------------------		

def dump_results(results,filename=None,dest_dir=None):
	
	#this will be the family dir for rnac and genome dir for multiple genomes under family
	#make it work for either single file or directory of files  
	
	#need to pass here the structure from merge results
	'''
        This function gathers all result files generated from cmsearch/cmscan
        results: This should be a file or a directory containing the cmsearch/scan 
        in tabular format.
        
        results:  The path to the cmscan/cmsearch outputs. The files must be in Infernal's
        		  tblout format
        filename: A string indicating the dump filename. If not provided res_dump.txt
        		  is used instead
        dest_dir: The path to the output directory. If not provided, results directory 
        		  is used by default
    '''
	
	res_files = None
	dest_dir = None
	dump_name = None
	
	if(filename==None):
		dump_name = "res_dump.txt" #or maybe the family name here
	else:
		dump_name = filename
	
	if(os.path.isdir(results)):
		fl = os.listdir(results) 
		res_files = filter(lambda x: string.find(x,OUT_EXT)!=-1,fl)
	else:
		res_files = [os.path.split(results)[1]]
		
	if (dest_dir==None):
		if (os.path.isdir(results)):
			dest_dir = results
		else:
			dest_dir = os.path.split(results)[0]
			
	dump_file = open(os.path.join(dest_dir,dump_name),'w')    
	dump_file.write("seq_acc\tfam_acc\tstart\tend\tscore\n") # add a header

	for res_file in res_files:
		
		fp = open(os.path.join(dest_dir,res_file),'r')
		
		#drop header lines
		fp.readline()
		fp.readline()
		
		#parse result lines
		for line in fp:
			line = string.split(string.strip(line))
			if (line[0]!='#'):
				#seq_acc,family_acc,start,end,score
				dump_file.write(line[0]+DELIMITER+line[3]+DELIMITER+line[7]+DELIMITER+line[8]+DELIMITER+line[14]+'\n')          
				
	dump_file.close()
	fp.close()

#----------------------------------------------------------------------------------------------------

def split_fasta(seq_file,seq_no,filename=None,h_line=False,out_dir=None):
	
	#remove h_line param - need to look into this
	
	'''
        Splits a sequence file in fasta format in smaller files according to seq_no, 
        which defines the number of sequences within each subset.
        
        seq_file:   The input sequence file in fasta format
        seq_no:     The number of sequences per file
        filename:   A string indicating the name for the output files. If not provided the
                    seq_file filename is used instead. An index number is also appended to
                    each subfile 
        h_line:     Boolean indicating whether the seq file contains a header/description line or not. 
                    False by default.
        out_dir:    The path to the desired output directory. If not provided, input file directory
                    is used by default.
    '''

	seq_count = 0
	file_count = 1 #generate unique identifiers for each new file
	header = ''
	
	fp = open(seq_file,'r')
	
	if(h_line==True):
		header = fp.readline()
		
	#if output directory is not provided, input directory is used
	if(out_dir==None):
		out_dir = os.path.split(seq_file)[0]
		
	#If no name provided, use input filename
	if (filename==None):
		filename = os.path.split(seq_file)[1].partition('.')[0]
		
	fp_out = open(os.path.join(out_dir,filename+str(file_count)+".fa"),'w')
	
	for line in fp:
		#write header if it exists
		if(h_line==True and seq_count==0):
			fp_out.write(header)
			
		if(seq_count<seq_no):
			if(string.find(line,'>')!=-1):
				seq_count = seq_count+1
				
			fp_out.write(line)
			
		elif(seq_count==seq_no):
			#not a header line
			if(string.find(line,'>')==-1):
				fp_out.write(line)   
				
			else:
				fp_out.close()    
				seq_count = 0
				file_count = file_count+1
				fp_out = open(os.path.join(out_dir,filename+str(file_count)+".fa"),'w') 
				fp_out.write(line)
				seq_count = seq_count+1 
				
	fp_out.close()
#----------------------------------------------------------------------------------------------------

if __name__=='__main__':

	pass
	
	
	
	
	
	
	





